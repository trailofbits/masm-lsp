# Miden VM Instruction Reference Data
# This file is parsed at compile time to generate a static instruction lookup table.
# Format: instruction_name = "short description"

# Comparison Operations
lte = "Compare if a <= b."
"lte.b" = "Compare if a <= b."
lt = "Compare if a < b."
"lt.b" = "Compare if a < b."
gte = "Compare if a >= b."
"gte.b" = "Compare if a >= b."
gt = "Compare if a > b."
"gt.b" = "Compare if a > b."
eq = "Compare if a = b."
"eq.b" = "Compare if a = b."
neq = "Compare if a != b."
"neq.b" = "Compare if a != b."
eqw = "Compare if word A = word B."
is_odd = "Check if a is odd."

# Assertions and Tests
assert = "Removes a if a = 1. Fails if a != 1."
assertz = "Removes a if a = 0. Fails if a != 0."
assert_eq = "Removes a, b if a = b. Fails if a != b."
assert_eqw = "Removes A, B if A = B. Fails if A != B."

# Arithmetic and Boolean Operations
add = "c = (a + b) mod p."
"add.b" = "c = (a + b) mod p."
sub = "c = (a - b) mod p."
"sub.b" = "c = (a - b) mod p."
mul = "c = (a * b) mod p."
"mul.b" = "c = (a * b) mod p."
div = "c = (a * b^-1) mod p. Fails if b = 0."
"div.b" = "c = (a * b^-1) mod p. Fails if b = 0."
neg = "b = -a mod p."
inv = "b = a^-1 mod p. Fails if a = 0."
pow2 = "b = 2^a. Fails if a > 63."
exp = "c = a^b."
"exp.u64" = "c = a^b."
"exp.b" = "c = a^b."
ilog2 = "b = floor(log2(a)). Fails if a = 0."
not = "b = 1 - a. Fails if a > 1."
and = "c = a * b. Fails if max(a, b) > 1."
or = "c = a + b - a * b. Fails if max(a, b) > 1."
xor = "c = a + b - 2 * a * b. Fails if max(a, b) > 1."

# Extension Field Operations
ext2add = "Extension field addition."
ext2sub = "Extension field subtraction."
ext2mul = "Extension field multiplication."
ext2neg = "Extension field negation."
ext2inv = "Extension field inverse. Fails if a = 0."
ext2div = "Extension field division. Fails if b = 0."

# U32 Conversions and Tests
u32test = "Test if a < 2^32."
u32testw = "Test if all elements of A < 2^32."
u32assert = "Fails if a >= 2^32."
u32assert2 = "Fails if a >= 2^32 or b >= 2^32."
u32assertw = "Fails if any element of A >= 2^32."
u32cast = "b = a mod 2^32."
u32split = "b = a mod 2^32, c = floor(a / 2^32)."

# U32 Arithmetic Operations
u32overflowing_add = "c = (a + b) mod 2^32, with overflow flag."
"u32overflowing_add.b" = "c = (a + b) mod 2^32, with overflow flag."
u32wrapping_add = "c = (a + b) mod 2^32."
"u32wrapping_add.b" = "c = (a + b) mod 2^32."
u32overflowing_add3 = "d = (a + b + c) mod 2^32, with overflow."
u32wrapping_add3 = "d = (a + b + c) mod 2^32."
u32overflowing_sub = "c = (a - b) mod 2^32, with borrow flag."
"u32overflowing_sub.b" = "c = (a - b) mod 2^32, with borrow flag."
u32wrapping_sub = "c = (a - b) mod 2^32."
"u32wrapping_sub.b" = "c = (a - b) mod 2^32."
u32overflowing_mul = "c = (a * b) mod 2^32, d = high bits."
"u32overflowing_mul.b" = "c = (a * b) mod 2^32, d = high bits."
u32wrapping_mul = "c = (a * b) mod 2^32."
"u32wrapping_mul.b" = "c = (a * b) mod 2^32."
u32overflowing_madd = "d = (a * b + c) mod 2^32, with overflow."
u32wrapping_madd = "d = (a * b + c) mod 2^32."
u32div = "c = floor(a / b). Fails if b = 0."
"u32div.b" = "c = floor(a / b). Fails if b = 0."
u32mod = "c = a mod b. Fails if b = 0."
"u32mod.b" = "c = a mod b. Fails if b = 0."
u32divmod = "c = floor(a / b), d = a mod b. Fails if b = 0."
"u32divmod.b" = "c = floor(a / b), d = a mod b. Fails if b = 0."

# U32 Bitwise Operations
u32and = "Bitwise AND. Fails if max(a, b) >= 2^32."
"u32and.b" = "Bitwise AND. Fails if max(a, b) >= 2^32."
u32or = "Bitwise OR. Fails if max(a, b) >= 2^32."
"u32or.b" = "Bitwise OR. Fails if max(a, b) >= 2^32."
u32xor = "Bitwise XOR. Fails if max(a, b) >= 2^32."
"u32xor.b" = "Bitwise XOR. Fails if max(a, b) >= 2^32."
u32not = "Bitwise NOT. Fails if a >= 2^32."
"u32not.a" = "Bitwise NOT. Fails if a >= 2^32."
u32shl = "c = (a * 2^b) mod 2^32."
"u32shl.b" = "c = (a * 2^b) mod 2^32."
u32shr = "c = floor(a / 2^b)."
"u32shr.b" = "c = floor(a / 2^b)."
u32rotl = "Rotate left."
"u32rotl.b" = "Rotate left."
u32rotr = "Rotate right."
"u32rotr.b" = "Rotate right."
u32popcnt = "Population count (Hamming weight)."
u32clz = "Count leading zeros."
u32ctz = "Count trailing zeros."
u32clo = "Count leading ones."
u32cto = "Count trailing ones."

# U32 Comparison Operations
u32lt = "Compare if a < b (u32)."
"u32lt.b" = "Compare if a < b (u32)."
u32lte = "Compare if a <= b (u32)."
"u32lte.b" = "Compare if a <= b (u32)."
u32gt = "Compare if a > b (u32)."
"u32gt.b" = "Compare if a > b (u32)."
u32gte = "Compare if a >= b (u32)."
"u32gte.b" = "Compare if a >= b (u32)."
u32min = "c = min(a, b)."
"u32min.b" = "c = min(a, b)."
u32max = "c = max(a, b)."
"u32max.b" = "c = max(a, b)."

# Stack Manipulation
drop = "Deletes the top stack item."
dropw = "Deletes a word (4 elements) from the top."
padw = "Pushes four 0 values onto the stack."
dup = "Pushes a copy of the top stack item."
dupw = "Pushes a copy of the top stack word."
swap = "Swaps the top two stack items."
swapw = "Swaps the top two stack words."
swapdw = "Swaps words: 1st with 3rd, 2nd with 4th."
movup = "Moves the nth stack item to the top."
movupw = "Moves the nth stack word to the top."
movdn = "Moves the top stack item to the nth position."
movdnw = "Moves the top stack word to the nth position."

# Conditional Manipulation
cswap = "If c = 1, swap a and b."
cswapw = "If c = 1, swap words A and B."
cdrop = "If c = 1, d = b. If c = 0, d = a."
cdropw = "If c = 1, D = B. If c = 0, D = A."

# Constant Inputs
push = "Pushes field elements onto the stack."

# Environment Inputs
clk = "Pushes current clock cycle."
sdepth = "Pushes current stack depth."
caller = "Pushes hash of the caller function."
locaddr = "Pushes address of local memory at index i."
procref = "Pushes MAST root of procedure."

# Advice Provider
adv_push = "Pops n values from advice stack to operand stack."
adv_loadw = "Pops word from advice stack to operand stack."
adv_pipe = "Pops 2 words from advice stack and writes to memory."
"adv.push_mapval" = "Pushes values from advice_map[K] to advice stack."
"adv.push_mapvaln" = "Pushes [n, values...] from advice_map[K]."
"adv.push_mtnode" = "Pushes Merkle tree node to advice stack."
"adv.insert_mem" = "advice_map[K] = mem[a..b]."
"adv.insert_hdword" = "Inserts hash of A||B into advice_map."
"adv.insert_hdword_d" = "Inserts hash(A||B, domain=d) into advice_map."
"adv.insert_hqword" = "Inserts hash of A||B||C||D into advice_map."
"adv.insert_hperm" = "Inserts permute(C,A,B).digest into advice_map."

# Memory Operations
mem_load = "v = mem[a]. Pushes element from memory."
"mem_load.a" = "v = mem[a]. Pushes element from memory."
mem_loadw_be = "A = mem[a..a+3]. Loads word big-endian."
"mem_loadw_be.a" = "A = mem[a..a+3]. Loads word big-endian."
mem_loadw_le = "A = mem[a..a+3]. Loads word little-endian."
"mem_loadw_le.a" = "A = mem[a..a+3]. Loads word little-endian."
mem_store = "mem[a] = v. Stores element to memory."
"mem_store.a" = "mem[a] = v. Stores element to memory."
mem_storew_be = "mem[a..a+3] = A. Stores word big-endian."
"mem_storew_be.a" = "mem[a..a+3] = A. Stores word big-endian."
mem_storew_le = "mem[a..a+3] = A. Stores word little-endian."
"mem_storew_le.a" = "mem[a..a+3] = A. Stores word little-endian."
mem_stream = "Reads 2 sequential words from memory."

# Procedure Locals
loc_load = "v = local[i]. Pushes element from local memory."
loc_loadw_be = "A = local[i..i+3]. Loads word big-endian."
loc_loadw_le = "A = local[i..i+3]. Loads word little-endian."
loc_store = "local[i] = v. Stores element to local memory."
loc_storew_be = "local[i..i+3] = A. Stores word big-endian."
loc_storew_le = "local[i..i+3] = A. Stores word little-endian."

# Cryptographic Operations
hash = "B = hash(A). Rescue Prime Optimized hash."
hperm = "D,E,F = permute(C,A,B). RPO permutation."
hmerge = "C = hash(A,B). 2-to-1 RPO hash."
mtree_get = "Verifies Merkle path and returns node V."
mtree_set = "Updates Merkle tree node, returns old value."
mtree_merge = "Merges two Merkle trees."
mtree_verify = "Verifies Merkle path for node V."

# Flow Control
nop = "No operation. Increments cycle counter."
"if.true" = "Conditional execution if cond = 1."
"if.false" = "Conditional execution if cond = 0."
"repeat" = "Counter-controlled loop."
"while.true" = "Condition-controlled loop."

# Events
emit = "Emits an event to the host."
trace = "Emits a trace to the host."
log_precompile = "Absorbs precompile commitment into transcript."

# Debugging
debug = "Prints VM state (debug mode only)."
"debug.stack" = "Prints entire stack."
"debug.mem" = "Prints entire RAM."
"debug.local" = "Prints local memory of current procedure."

# Word operations
reversew = "Reverses the order of elements in top word."
