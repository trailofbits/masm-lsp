---
title: "Input / Output Operations"
sidebar_position: 8
---

## Input / output operations

Miden assembly provides a set of instructions for moving data between the operand stack and several other sources. These sources include:

- **Program code**: values to be moved onto the operand stack can be hard-coded in a program's source code.
- **Environment**: values can be moved onto the operand stack from environment variables. These include current clock cycle, current stack depth, and a few others.
- **Advice provider**: values can be moved onto the operand stack from the advice provider by popping them from the advice stack (see more about the advice provider [here](../../overview.md#nondeterministic-inputs)). The VM can also inject new data into the advice provider via _system event_ instructions.
- **Memory**: values can be moved between the stack and random-access memory. The memory is element-addressable, meaning that a single element is located at each address. However, reading and writing elements to/from memory in batches of four is supported via the appropriate instructions (e.g. `mem_loadw_be` or `mem_storew_le`). Memory can be accessed via absolute memory references (i.e., via memory addresses) as well as via local procedure references (i.e., local index). The latter approach ensures that a procedure does not access locals of another procedure.

### Constant inputs

| Instruction                                                                     | Stack_input | Stack_output                                         | Notes                                                                                                                                                                                               |
| ------------------------------------------------------------------------------- | ----------- | ---------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| push._a_ <br /> - _(1-2 cycles)_ <br /> push._a_._b_ <br /> push._a_._b_._c_... | [ ... ]     | [a, ... ] <br /> [b, a, ... ] <br /> [c, b, a, ... ] | Pushes values $a$, $b$, $c$ etc. onto the stack. Up to $16$ values can be specified. All values must be valid field elements in decimal (e.g., $123$) or hexadecimal (e.g., $0x7b$) representation. |

The value can be specified in hexadecimal form without periods between individual values as long as it describes a full word ($4$ field elements or $32$ bytes). Note that hexadecimal values separated by periods (short hexadecimal strings) are assumed to be in big-endian order, while the strings specifying whole words (long hexadecimal strings) are assumed to be in little-endian order. That is, the following are semantically equivalent:

```
push.0x00001234.0x00005678.0x00009012.0x0000abcd
push.0x341200000000000078560000000000001290000000000000cdab000000000000
push.4660.22136.36882.43981
```

In both case the values must still encode valid field elements.

### Environment inputs

| Instruction                          | Stack_input  | Stack_output | Notes                                                                                                                                                                                                                 |
| ------------------------------------ | ------------ | ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| clk <br /> - _(1 cycle)_             | [ ... ]      | [t, ... ]    | $t \leftarrow clock\_value()$ <br /> Pushes the current value of the clock cycle counter onto the stack.                                                                                                              |
| sdepth <br /> - _(1 cycle)_          | [ ... ]      | [d, ... ]    | $d \leftarrow stack.depth()$ <br /> Pushes the current depth of the stack onto the stack.                                                                                                                             |
| caller <br /> - _(1 cycle)_          | [A, b, ... ] | [H, b, ... ] | $H \leftarrow context.fn\_hash()$ <br /> In context 0, overwrites the top 4 stack items with hash `H` of the function that syscall'd into the current context, or `[0, 0, 0, 0]` when not servicing a `SYSCALL`. In any other context, `H` corresponds to the hash of the function that entered the current context. |
| locaddr.*i* <br /> - _(2 cycles)_    | [ ... ]      | [a, ... ]    | $a \leftarrow address\_of(i)$ <br /> Pushes the absolute memory address of local memory at index $i$ onto the stack.                                                                                                  |
| procref.*name* <br /> - _(4 cycles)_ | [ ... ]      | [A, ... ]    | $A \leftarrow mast\_root()$ <br /> Pushes MAST root of the procedure with name $name$ onto the stack.                                                                                                                 |

### Nondeterministic inputs

As mentioned above, nondeterministic inputs are provided to the VM via the advice provider. Instructs which access the advice provider fall into two categories. The first category consists of instructions which move data from the advice stack onto the operand stack and/or memory.

| Instruction                         | Stack_input        | Stack_output        | Notes                                                                                                                                                                                                                                                                                                                          |
| ----------------------------------- | ------------------ | ------------------- |--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| adv_push.*n* <br /> - _(n cycles)_ | [ ... ]            | [a, ... ]           | $a \leftarrow advstack.pop()$ <br /> Pops $n$ values from the advice stack and pushes them onto the operand stack. Valid for $n \in \{1, ..., 16\}$. <br /> Fails if the advice stack has fewer than $n$ values.                                                                                                               |
| adv_loadw <br /> - _(1 cycle)_     | [0, 0, 0, 0, ... ] | [A, ... ]           | $A \leftarrow advstack.pop(4)$ <br /> Pop the next word (4 elements) from the advice stack and overwrites the first word of the operand stack (4 elements) with them. <br /> Fails if the advice stack has fewer than $4$ values.                                                                                              |
| adv_pipe <br /> - _(1 cycle)_      | [C, B, A, a, ... ] | [E, D, A, a', ... ] | $[D, E] \leftarrow [adv\_stack.pop(4), adv\_stack.pop(4)]$ <br /> $a' \leftarrow a + 8$ <br /> Pops the next two words from the advice stack, overwrites the top of the operand stack with them and also writes these words into memory at address $a$ and $a + 4$.<br /> Fails if the advice stack has fewer than $8$ values. |

> **Note**: The opcodes above always push data onto the operand stack so that the first element is placed deepest in the stack. For example, if the data on the stack is `a,b,c,d` and you use the opcode `adv_push.4`, the data will be `d,c,b,a` on your stack. This is also the behavior of the other opcodes.

The second category injects new data into the advice provider. These operations are called _system events_ and they affect only the advice provider state. That is, the state of all other VM components (e.g., stack, memory) are unaffected. Handling system events uses the same mechanism as standard events using `emit` (i.e., these instructions are executed in $3$ cycles). System events use direct numeric event IDs in the reserved range 0-255, while user-defined events use string-based `EventId::from_name()` derivation with unique, descriptive names following hierarchical naming conventions to avoid conflicts.

System events fall into two categories: (1) events which push new data onto the advice stack, and (2) events which insert new data into the advice map.

| Instruction         | Stack_input        | Stack_output       | Notes                                                                                                                                                                                                                                                                |
| ------------------- | ------------------ | ------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| adv.push_mapval     | [K, ... ]          | [K, ... ]          | Pushes a list of field elements onto the advice stack. The list is looked up in the advice map using word $K$ as the key.                                                                                                                                            |
| adv.push_mapvaln    | [K, ... ]          | [K, ... ]          | Pushes a list of field elements together with the number of elements onto the advice stack (`[n, ele1, ele2, ...]`, where `n` is the number of elements pushed). The list is looked up in the advice map using word $K$ as the key.                                  |
| adv.has_mapkey      | [K, ... ]          | [K, ... ]          | Pushes `1` on the advice stack if the key placed at the top of the operand stack exists in the advice map, or `0` otherwise.                                                                                                                                         |
| adv.push_mtnode     | [d, i, R, ... ]    | [d, i, R, ... ]    | Pushes a node of a Merkle tree with root $R$ at depth $d$ and index $i$ from Merkle store onto the advice stack.                                                                                                                                                     |
| adv.insert_mem      | [K, a, b, ... ]    | [K, a, b, ... ]    | Reads words $data \leftarrow mem[a] .. mem[b]$ from memory, and save the data into $advice\_map[K] \leftarrow data$.                                                                                                                                                 |
| adv.insert_hdword   | [B, A, ... ]       | [B, A, ... ]       | Reads top two words from the stack, computes a key as $K \leftarrow hash(A \|\| B, domain=0)$, and saves the data into $advice\_map[K] \leftarrow [A, B]$.                                                                                                           |
| adv.insert_hdword_d | [B, A, d, ... ]    | [B, A, d, ... ]    | Reads top two words from the stack, computes a key as $K \leftarrow hash(A \|\| B, domain=d)$, and saves the data into $advice\_map[K] \leftarrow [A, B]$. $d$ is the domain value, where changing the domain changes the resulting hash given the same `A` and `B`. |
| adv.insert_hqword   | [D, C, B, A, ... ] | [D, C, B, A, ... ] | Reads top four words from the stack, computes a key as cumulative hash of these words $K \leftarrow hash(hash(hash(A \|\| B) \|\| C) \|\| D)$ in $domain=0$, and saves the data into $advice\_map[K] \leftarrow [A, B, C, D]$.                                       |
| adv.insert_hperm    | [B, A, C, ...]     | [B, A, C, ...]     | Reads top three words from the stack, computes a key as $K \leftarrow permute(C, A, B).digest$, and saves data into $advice\_map[K] \leftarrow [A, B]$.                                                                                                              |

### Random access memory

As mentioned above, there are two ways to access memory in Miden VM. The first way is via memory addresses using the instructions listed below. The addresses are absolute - i.e., they don't depend on the procedure context. Memory addresses can be in the range $[0, 2^{32})$.

Memory is guaranteed to be initialized to zeros. Thus, when reading from memory address which hasn't been written to previously, zero elements will be returned.

| Instruction                                                                           | Stack_input           | Stack_output        | Notes                                                                                                                                                                                                                                                                                                                                                                                      |
| ------------------------------------------------------------------------------------- | --------------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| mem_load <br /> - _(1 cycle)_ <br /> mem_load.*a* <br /> - _(2 cycles)_              | [a, ... ]             | [v, ... ]           | $v \leftarrow mem[a]$ <br /> Reads the field element from memory at address _a_, and pushes it onto the stack. If $a$ is provided via the stack, it is removed from the stack first. <br /> Fails if $a \ge 2^{32}$                                                                                                                                                                        |
| mem_loadw_be <br /> - _(1 cycles)_ <br /> mem_loadw_be.*a* <br /> - _(2 cycles)_     | [a, 0, 0, 0, 0, ... ] | [A, ... ]           | $A \leftarrow mem[a..(a+4)]$ <br /> Reads a word from memory starting at address $a$ and overwrites top four stack elements with it in big-endian (reversed) order, such that `mem[a+3]` is on top of the stack. If $a$ is provided via the stack, it is removed from the stack first. <br /> Fails if $a \ge 2^{32}$, or if $a$ is not a multiple of 4         |
| mem_loadw_le <br /> - _(4 cycles)_ <br /> mem_loadw_le.*a* <br /> - _(5 cycles)_     | [a, 0, 0, 0, 0, ... ] | [A, ... ]           | $A \leftarrow mem[a..(a+4)]$ <br /> Reads a word from memory starting at address $a$ and overwrites top four stack elements with it in little-endian (memory) order, such that `mem[a]` is on top of the stack. Equivalent to `mem_loadw_be reversew`. If $a$ is provided via the stack, it is removed from the stack first. <br /> Fails if $a \ge 2^{32}$, or if $a$ is not a multiple of 4 |
| mem_store <br /> - _(2 cycles)_ <br /> mem_store.*a* <br /> - _(3-4 cycles)_         | [a, v, ... ]          | [ ... ]             | $v \rightarrow mem[a]$ <br /> Pops the top element off the stack and stores it in memory at address $a$. If $a$ is provided via the stack, it is removed from the stack first. <br /> Fails if $a \ge 2^{32}$                                                                                                                                                                              |
| mem_storew_be <br /> - _(1 cycles)_ <br /> mem_storew_be.*a* <br /> - _(2-3 cycles)_ | [a, A, ... ]          | [A, ... ]           | $A \rightarrow mem[a..(a+4)]$ <br /> Stores the top four elements of the stack in big-endian (reversed) order in memory starting at address $a$, such that the top of stack is placed at `mem[a+3]`. If $a$ is provided via the stack, it is removed from the stack first. <br /> Fails if $a \ge 2^{32}$, or if $a$ is not a multiple of 4                    |
| mem_storew_le <br /> - _(9 cycles)_ <br /> mem_storew_le.*a* <br /> - _(8-9 cycles)_ | [a, A, ... ]          | [A, ... ]           | $A \rightarrow mem[a..(a+4)]$ <br /> Stores the top four elements of the stack in little-endian (memory) order in memory starting at address $a$, such that the top of stack is placed at `mem[a]`. Equivalent to `reversew mem_storew_be reversew`. If $a$ is provided via the stack, it is removed from the stack first. <br /> Fails if $a \ge 2^{32}$, or if $a$ is not a multiple of 4   |
| mem_stream <br /> - _(1 cycle)_                                                      | [C, B, A, a, ... ]    | [E, D, A, a', ... ] | $[E, D] \leftarrow [mem[a..(a+4)], mem[(a+4)..(a+8)]]$ <br /> $a' \leftarrow a + 8$ <br /> Read two sequential words from memory starting at address $a$ and overwrites the first two words in the operand stack.                                                                                                                                                                          |

The second way to access memory is via procedure locals using the instructions listed below. These instructions are available only in procedure context. The number of locals available to a given procedure must be specified at [procedure declaration](./code_organization.md#procedures) time, and trying to access more locals than was declared will result in a compile-time error. A procedure can have at most $2^{16}$ locals, and the total number of locals available to all procedures at runtime is limited to $2^{31} - 1$. The assembler internally always rounds up the number of declared locals to the nearest multiple of 4.

> Accessing a memory local requires reading the frame memory pointer stored in memory, and hence incurs an extra memory read, as well as 2 stack-manipulating operations.

| Instruction                                | Stack_input        | Stack_output | Notes                                                                                                                                                                                                                                                                |
| ------------------------------------------ | ------------------ | ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| loc_load.*i* <br /> - _(3-4 cycles)_      | [ ... ]            | [v, ... ]    | $v \leftarrow local[i]$ <br /> Reads a field element from local memory at index _i_, and pushes it onto the stack.                                                                                                                                                   |
| loc_loadw_be.*i* <br /> - _(3-4 cycles)_  | [0, 0, 0, 0, ... ] | [A, ... ]    | $A \leftarrow local[i..(i+4)]$ <br /> Reads a word from local memory starting at index $i$ in big-endian (reversed) order, such that `local[i+3]` is placed at the top of the stack. Fails if $i$ is not a multiple of 4.                                           |
| loc_loadw_le.*i* <br /> - _(7-8 cycles)_  | [0, 0, 0, 0, ... ] | [A, ... ]    | $A \leftarrow local[i..(i+4)]$ <br /> Reads a word from local memory starting at index $i$ in little-endian (memory) order, such that `local[i]` is placed at the top of the stack. Equivalent to `loc_loadw_be reversew`. Fails if $i$ is not a multiple of 4.    |
| loc_store.*i* <br /> - _(4-5 cycles)_     | [v, ... ]          | [ ... ]      | $v \rightarrow local[i]$ <br /> Pops the top element off the stack and stores it in local memory at index $i$.                                                                                                                                                       |
| loc_storew_be.*i* <br /> - _(3-4 cycles)_ | [A, ... ]          | [A, ... ]    | $A \rightarrow local[i..(i+4)]$ <br /> Stores the top four elements of the stack in local memory in big-endian (reversed) order starting at index $i$, such that the top of stack is placed at `local[i+3]`.                                                         |
| loc_storew_le.*i* <br /> - _(11-12 cycles)_ | [A, ... ]          | [A, ... ]    | $A \rightarrow local[i..(i+4)]$ <br /> Stores the top four elements of the stack in local memory in little-endian (memory) order starting at index $i$, such that the top of stack is placed at `local[i]`. Equivalent to `reversew loc_storew_be reversew`.        |

Unlike regular memory, procedure locals are not guaranteed to be initialized to zeros. Thus, when working with locals, one must assume that before a local memory address has been written to, it contains "garbage".

Internally in the VM, procedure locals are stored at memory offset starting at $2^{31}$. Thus, every procedure local has an absolute address in regular memory. The `locaddr.i` instruction is provided specifically to map an index of a procedure's local to an absolute address so that it can be passed to downstream procedures, when needed.
