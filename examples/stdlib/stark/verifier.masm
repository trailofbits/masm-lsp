use std::pcs::fri::frie2f4
use std::pcs::fri::helper

use std::stark::deep_queries
use std::stark::random_coin
use std::stark::ood_frames
use std::stark::public_inputs
use std::stark::constants
use std::stark::utils

#! Verifies a STARK proof.
#!
#! The purpose of the following verifier is to serve as a generic core around which a specific
#! verifier can be built. It expects the following parameters on the stack from the caller:
#!
#! 1. `[D0, D1, D2, D3]` which are respectively the digests for dynamic execution of procedures
#!   i. `compute_deep_composition_polynomial_queries`
#!   ii. `execute_constraint_evaluation_check`
#!   iii. `process_row_ood_evaluations`
#!   iv. `process_public_inputs`
#! 2. `num_constraints` which is the number of constraints in the AIR
#! 3. `trace_info` which is a field element encoding the layout of the AIR
#! 4. `num_fixed_len_pi` is the number of fixed length public inputs of the AIR
#! 5. `is_aux_trace` flag indicating the existence of an auxiliary segment in this AIR
#!
#! In addition to the above parameters, the verifier expects the following auxiliary proof parameters:
#!
#! 1. `log(trace_length)`, the logarithm base 2 of the trace length
#! 2. `num_queries`, the number of FRI queries
#! 3. `grinding`, the number of bits of grinding i.e., proof-of-work
#!
#! The following simplifying assumptions are currently made and hardcoded:
#!
#! - The blowup factor is set to 8.
#! - The maximal allowed degree of the remainder polynomial is 127.
#! - To boost soundness, the protocol is run on a quadratic extension field and this means that
#!   the OOD evaluation frame is composed of elements in a quadratic extension field i.e. tuples.
#!   Similarly, elements of the auxiliary trace are quadratic extension field elements. The random
#!   values for computing random linear combinations are also in this extension field.
#!
#! Inputs:  [D3, D2, D1, D0, log(trace_length), num_queries, grinding, num_constraints, trace_info, num_fixed_len_pi, is_aux_trace]
#! Outputs: []
pub proc verify

    #==============================================================================================
    #       I)  Hash proof context and hash-&-load public inputs
    #==============================================================================================

    # Store digests of dynamically executed procedures
    exec.utils::store_dynamically_executed_procedures
    # => [log(trace_length), num_queries, grinding, num_constraints, trace_info, num_fixed_len_pi, is_aux_trace, ...]

    # Validate inputs
    #
    # Cycles: 45
    exec.utils::validate_inputs
    # => [log(trace_length), num_queries, grinding, num_constraints, trace_info, num_fixed_len_pi, is_aux_trace, ...]

    # Initialize the seed using proof context
    #
    # Cycles: 210
    exec.random_coin::init_seed
    # => [C, is_aux_trace, ...]

    # Load public inputs
    exec.public_inputs::process_public_inputs
    # => [is_aux_trace, ...]

    #==============================================================================================
    #       II) Generate the auxiliary trace random elements if auxiliary segment exists
    #==============================================================================================

    # Load main trace commitment and re-seed with it
    #
    # Cycles: 56
    padw
    adv_loadw
    exec.constants::main_trace_com_ptr mem_storew_be
    # => [main_trace_commitment, is_aux_trace, ...]
    exec.random_coin::reseed
    # => [is_aux_trace, ...]

    # If auxiliary segment exists, generate auxiliary randomness and reseed with commitment
    # to auxiliary segment
    if.true
        # Draw random ExtFelt for the auxiliary trace
        #
        # Cycles: 12
        exec.random_coin::generate_aux_randomness
        # => [...]

        # Reseed with auxiliary trace commitment
        #
        # Cycles: 64
        padw
        adv_loadw
        exec.constants::aux_trace_com_ptr mem_storew_be
        exec.random_coin::reseed
        # => [...]
    end

    #==============================================================================================
    #       III) Draw constraint composition coefficients
    #==============================================================================================

    # Cycles: 13
    exec.random_coin::generate_constraint_composition_coefficients
    # => [...]

    #==============================================================================================
    #       IV) Reseed with commitment to constraint composition polynomial H evaluations over LDE
    #          and generate the Out-of-Domain (OOD) challenge z
    #==============================================================================================

    # Reseed with constraint composition polynomial commitment
    #
    # Cycles: 88 + 18 * log(trace_length)
    padw
    adv_loadw
    exec.constants::composition_poly_com_ptr mem_storew_be
    exec.random_coin::reseed
    exec.random_coin::generate_z_zN
    # => [...]

    #==============================================================================================
    #       V) Read the OOD frames for the main trace, auxiliary trace and the trace of evaluations
    #           of H over the LDE domain. This also computes some values needed for the computation
    #           of the DEEP queries.
    #==============================================================================================

    exec.ood_frames::load_and_horner_eval_ood_frames

    #==============================================================================================
    #       VI) Constraint evaluation check
    #==============================================================================================

    exec.utils::execute_constraint_evaluation_check

    #==============================================================================================
    #       VII) FRI
    #==============================================================================================

    #============================================
    #   1) Draw random coefficients for computing
    #       DEEP composition polynomial.
    #============================================

    # Cycles: 14
    exec.random_coin::generate_deep_composition_random_coefficients

    #============================================
    #   2) Compute constants needed for computing
    #       FRI queries. These are:
    #       -   LDE domain generator.
    #       -   Trace domain generator `g`.
    #       -   `gz`.
    #       -   Number of FRI layers.
    #============================================

    # Cycles: 77
    exec.helper::generate_fri_parameters
    # => [...]

    #============================================
    #   3) Load and reseed with FRI layer commitments
    #      and draw the folding challenges for
    #      computing the degree respecting projection
    #============================================

    # Cycles: 40 + 108 * num_fri_layers
    exec.helper::load_fri_layer_commitments
    # => [...]

    #============================================
    #   4) Load and check commitment to remainder
    #      polynomial.
    #============================================

    # Cycles:
    #  1- Remainder polynomial of degree less
    #     than 64: 157
    #  2- Remainder polynomial of degree less
    #     than 128: 191
    exec.helper::load_and_verify_remainder
    # => [...]

    #============================================
    #   5) Check PoW nonce
    #============================================

    # Cycles: 78
    exec.random_coin::check_pow
    # => [...]

    #============================================
    #   6) Compute evaluations of DEEP composition
    #   polynomial at randomly chosen query positions
    #============================================

    # Compute the pointer to the first query using the pointer to
    # the first layer commitment and the total number of queries.
    exec.helper::compute_query_pointer

    # Draw random query indices
    exec.random_coin::generate_list_indices
    # => [...]

    # Compute deep composition polynomial queries
    exec.deep_queries::compute_deep_composition_polynomial_queries
    # => [...]

    #============================================
    #   7) Call the FRI verifier
    #============================================

    # Call FRI verifier
    #
    # Cycles:
    #  1- Remainder of size 64: 18 + num_queries * (107 + num_layers * 83)
    #  2- Remainder of size 128: 18 + num_queries * (140 + num_layers * 83)
    exec.frie2f4::verify
end
