use std::crypto::hashes::keccak256
use std::crypto::hashes::rpo
use std::sys
use std::word

# ENCODING CONVENTIONS
# ================================================================================================
#
# This module uses the following notation for data representation:
# - Byte arrays are stored in memory as packed u32 values in little-endian format
# - Each u32 represents 4 bytes: u32 = u32::from_le_bytes([b0, b1, b2, b3])
# - Unused bytes in the final u32 must be set to zero
# - Memory addresses must be word-aligned (divisible by 4)

# Constants
# ================================================================================================

const ECDSA_VERIFY_EVENT = event("stdlib::crypto::dsa::ecdsa::verify")

const PK_LEN_FELTS = 9     # 33.div_ceil(4)
const DIGEST_LEN_FELTS = 8 # 32.div_ceil(4)
const SIG_LEN_FELTS = 17   # 66.div_ceil(4)

# PROCEDURES
# ================================================================================================

#! Verifies an secp256k1 ECDSA signature compatible with `miden-crypto::ecdsa_k256_keccak`.
#!
#! This wrapper mirrors the materialization performed in `miden-crypto::ecdsa_k256_keccak`: given
#! a public key commitment and the original message, it reconstructs the calldata expected by the
#! precompile (public key bytes, Keccak256(message), signature). The public key and signature are
#! supplied via the advice stack, and can be obtained with the `ecdsa_k256_keccak` function.
#!
#! Inputs:
#!   Operand stack: [PK_COMM, MSG, ...]
#!   Advice stack:  [PK[9] | SIG_BYTES[17] | ...]
#! Outputs:
#!   Operand stack: []
#!   Advice stack:  []
#!
#! Local memory layout (element addresses):
#!   - locaddr[0 ..9 ] : compressed public key (33 bytes packed as 9 felts)
#!   - locaddr[12..20] : message bytes (MSG written as eight u32 limbs)
#!   - locaddr[20..28] : keccak256(message) digest (8 felts)
#!   - locaddr[28..45] : signature (66 bytes packed as 17 felts)
#!
#! The procedure traps if the public key in the advice stack does not hash to `PK_COMM`;
#! otherwise it returns cleanly after emitting the deferred verification request.
@locals(48)
pub proc verify_ecdsa_k256_keccak
    # Load the compressed public key (9 felts) into local memory at locaddr.[0..9]
    adv_push.4 loc_storew_be.0
    adv_loadw  loc_storew_be.4 dropw
    adv_push.1 loc_store.8

    # Compute the expected commitment and ensure it matches the provided PK_COMM
    push.PK_LEN_FELTS locaddr.0 exec.rpo::hash_memory
    assert_eqw.err="invalid public key commitment"
    # => [MSG, ...]

    # Materialize the message bytes at locaddr.[12..20]
    locaddr.12 movdn.4 exec.word::store_word_u32s_le
    # [...]

    # Hash the 32-byte message with Keccak256
    push.32 locaddr.12 exec.keccak256::hash_memory
    # => [DIGEST[0..8], ...]

    # Store the resulting digest at locaddr.[20..28]
    loc_storew_le.20 dropw
    loc_storew_le.24
    # => [DIGEST[4..8], ...]

    # store the signature (17 felts) provided via advice at locaddr.[28..45]
    adv_loadw  loc_storew_be.28
    adv_loadw  loc_storew_be.32
    adv_loadw  loc_storew_be.36
    adv_loadw  loc_storew_be.40 dropw
    adv_push.1 loc_store.44
    # => [...]

    # Invoke the deferred verification precompile with in-memory calldata
    locaddr.28
    locaddr.20
    locaddr.0
    # => [pk_ptr, digest_ptr, sig_ptr]
    exec.verify
    # => [result, ...]
    assert.err="ECDSA signature verification failed"
end

#! Verifies an ECDSA signature with pre-hashed message using deferred execution.
#!
#! The caller provides the public key, the pre-hashed message digest, and the signature data in
#! memory. This routine forwards the request to the host precompile and returns the boolean result.
#! In typical flows the digest is obtained from `keccak256::hash_memory`, but any 32-byte prehash
#! is accepted.
#!
#! Input: `[pk_ptr, digest_ptr, sig_ptr, ...]`
#! Output: `[result, ...]`
#!
#! Where:
#! - `pk_ptr`: word-aligned memory address containing the 33-byte compressed secp256k1 public key
#! - `digest_ptr`: word-aligned memory address containing the 32-byte message digest
#! - `sig_ptr`: word-aligned memory address containing the 66-byte signature
#! - `result`: 1 if the signature is valid, 0 if invalid
#!
#! All data must be stored in memory as packed u32 values (little-endian), with unused bytes
#! in the final u32 set to zero.
pub proc verify
    exec.verify_impl
    # => [COMM, TAG, result, ...]

    # Log the precompile request for deferred verification
    exec.sys::log_precompile_request
    # => [result, ...]
end

# INTERNAL PROCEDURES
# ================================================================================================

#! Internal implementation of ECDSA signature verification via deferred computation.
#!
#! Emits an event to trigger the precompile handler, reads the verification result from
#! the advice stack, and computes the commitment and tag for tracking deferred verification.
#!
#! This procedure mimics the `ecdsa_secp256k1::PublicKey::verify_prehash()` function from
#! `miden-crypto`, which takes a pre-hashed message that the caller must provide
#! (e.g. obtained using the keccak256 precompile).
#!
#! Input: `[pk_ptr, digest_ptr, sig_ptr, ...]`
#! Output: `[COMM, TAG, result, ...]`
#!
#! Where:
#! - `pk_ptr`: word-aligned memory address containing 33-byte public key
#! - `digest_ptr`: word-aligned memory address containing 32-byte digest
#! - `sig_ptr`: word-aligned memory address containing 66-byte signature
#! - `COMM`: commitment to calldata computed as
#!       `Rpo256(Rpo256(Rpo256(pk) || Rpo256(digest)) || Rpo256(sig))`
#! - `TAG`: `[ECDSA_VERIFY_EVENT, result, 0, 0]`
#! - `result`: 1 if signature is valid, 0 if invalid
pub proc verify_impl
    emit.ECDSA_VERIFY_EVENT
    # => [pk_ptr, digest_ptr, sig_ptr, ...]

    # Read verification result from advice stack (provided by the host)
    adv_push.1
    # => [result, pk_ptr, digest_ptr, sig_ptr, ...]

    # Compute commitment: COMM = Rpo256(Rpo256(Rpo256(pk) || Rpo256(digest)) || Rpo256(sig))
    # Compute COMM_PK = Rpo256(pk)
    push.PK_LEN_FELTS movup.2 exec.rpo::hash_memory
    # => [COMM_PK, result, digest_ptr, sig_ptr]

    # Compute COMM_DIGEST = Rpo256(digest_bytes)
    push.DIGEST_LEN_FELTS movup.6 exec.rpo::hash_memory
    # => [COMM_DIGEST, COMM_PK, result, sig_ptr]

    # Merge COMM_PK and COMM_DIGEST into COMM_PK_DIGEST = Rpo256(Rpo256(pk) || Rpo256(digest))
    hmerge
    # => [COMM_PK_DIGEST, result, sig_ptr]

    # Compute COMM_SIG = Rpo256(sig_bytes)
    push.SIG_LEN_FELTS movup.6 exec.rpo::hash_memory
    # => [COMM_SIG, COMM_PK_DIGEST, result]

    # Merge into final commitment COMM = Rpo256(COMM_PK_DIGEST || COMM_SIG)
    hmerge
    # => [COMM, result]

    # Create TAG = [ECDSA_VERIFY_EVENT, result, 0, 0]
    push.ECDSA_VERIFY_EVENT dup.5 push.0.0 swapw
    # => [COMM, TAG, result]
end
