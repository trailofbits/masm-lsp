use std::crypto::hashes::rpo
use std::collections::sorted_array
use std::math::u64
use std::mem
use std::sys
use std::word

# Constant value for the depth at which leaves sit
const LEAF_DEPTH = 64

# Each key-value pair is two words, and a leaf can hold up to 1024 pairs.
const MAX_LEAF_SIZE = 8192

# EXPORTS
# =================================================================================================

#! Returns the value located under the specified key in the Sparse Merkle Tree defined by the
#! specified root.
#!
#! If no values had been previously inserted under the specified key, an empty word (i.e.,
#! [ZERO; 4]) is returned.
#!
#! Inputs:
#!   Operand stack: [K, R, ...]
#!
#! Outputs:
#!   Operand stack: [V, R, ...]
#!
#! Fails if the tree with the specified root does not exits in the VM's advice provider.
#!
#! Cycles
#!   Leaf empty: 66 cycles
#!   Leaf single: 115 cycles
#!   Leaf multiple, non-empty value: 189 + 3 * pair_count
#!   Leaf multiple, empty value: 186 + 3 * pair_count
pub proc get
    # Prepare for `mtree_get`
    # (6 cycles)
    dupw.1 dup.4 push.LEAF_DEPTH
    # => [depth, K[3], R, K, R]

    # Retrieve node value from merkle store
    # (14 cycles)
    mtree_get swapw dropw
    # => [NV, K, R]

    # Check if value is empty; if so, return empty value
    # (19 cycles)
    padw eqw
    # => [NV == 0, ZERO, V, K, R]

    if.true
        # Return empty value
        # (9 cycles)
        dropw swapw dropw
        # => [NV, R]
    else
        # Drop extra ZERO word
        # (4 cycles)
        dropw
        # => [NV, K, R]

        # Get leaf pre-image from advice map. Push the leaf preimage size on the stack
        # (0 cycles)
        adv.push_mapvaln adv_push.1
        # => [leaf_size, NV, K, R]

        # Consistency check: assert this is actually a valid leaf.
        # (18 cycles).
        dup u32assert2 u32lte.MAX_LEAF_SIZE assert.err="invalid leaf: larger than maximum size of 8192"
        dup u32mod.8 assertz.err="invalid leaf: size must be a multiple of 8"

        # Leaf size will be a multiple of 8 (each kv-pair in a leaf is 8 elements)
        # (3 cycles)
        dup eq.8
        # => [is_single_kv_pair, leaf_size, NV, K, R]

        if.true
            # Single kv-pair case

            # Push leaf pre-image on stack (single K-V pair)
            # (1 cycle)
            drop adv_push.8
            # => [V, K, NV, K, R]

            # Confirm that the key stored in the leaf is as expected
            # (18 cycles)
            movupw.3 dupw.2 assert_eqw
            # => [V, K, NV, R]

            # Duplicate V to return it after hash check
            # (7 cycles)
            dupw movdnw.3
            # => [V, K, NV, V, R]

            # Hash leaf preimage and ensure that it equals node value
            # (27 cycles)
            hmerge assert_eqw
            # => [V, R]
        else
            # => [leaf_size, NV, K, R]

            # (125 + 3 * leaf_size / 8 cycles if V is not empty)
            # (122 + 3 * leaf_size / 8 cycles if V is empty)
            exec.get_multi_leaf_value
            # => [V, R]
        end
    end
end


#! Inserts the specified value under the specified key in a Sparse Merkle Tree defined by the
#! specified root. If the insert is successful, the old value located under the specified key
#! is returned via the stack.
#!
#! If the VALUE is an empty word (i.e., [ZERO; 4]), the new state of the tree is guaranteed to
#! be equivalent to the state as if the updated value was never inserted.
#!
#! Inputs:
#!   Operand stack: [V, K, R, ...]
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
#!
#! Fails if the tree with the specified root does not exits in the VM's advice provider.
#!
#! Cycles
#!   Leaf empty
#!     removal: 74 cycles
#!     insertion: 133 cycles
#!   Leaf single
#!     removal: 227 cycles
#!     insertion (leaf remains single): 205
#!     insertion (leaf becomes multiple): X cycles
#!   Leaf multiple
#!     X cycles
pub proc set
    # Prepare stack for adv.push_mtnode
    # (X cycles)
    movupw.2 dup.8 push.LEAF_DEPTH
    # => [depth, leaf_index, R, V, K]

    # Push MT node on advice stack, cleanup operand stack, and then
    # push MT node on operand stack (NV)
    # (X cycles)
    adv.push_mtnode drop drop movdnw.2 adv_push.4
    # => [NV, V, K, R]

    # (X cycles)
    padw eqw
    # => [NV == ZERO, ZERO, NV, V, K, R]

    if.true
        # empty leaf

        # (8 cycles)
        dropw dropw
        #=> [V, K, R]

        # (insert empty value: X cycles)
        # (insert non-empty value: X cycles)
        exec.set_empty_leaf
    else
        # Single or Multiple leaf

        # (X cycles)
        dropw
        # => [NV, V, K, R]

        # Retrieve leaf pre-image on advice stack, and push leaf size on stack
        # Note: the rest of the leaf pre-image will be pulled out later
        # (4 cycles)
        adv.push_mapvaln adv_push.1
        # => [leaf_size, NV, V, K, R]

        # Leaf size will be a multiple of 8 (each kv-pair in a leaf is 8 elements)
        # (3 cycles)
        dup eq.8
        # => [is_single_kv_pair, leaf_size, NV, V, K, R]

        if.true
            #  Single kv-pair case

            # (1 cycle)
            drop dropw
            # => [V, K, R]

            # (remove key/value: X cycles)
            # (insert; leaf single after insertion: X cycles)
            # NOTE: set_single_leaf includes the case where the single leaf
            # becomes a multi-leaf.
            exec.set_single_leaf
        else
            # Multiple kv-pair case

            # Ensure that the leaf size does not exceed the maximum size of 1024 k-v pairs.
            dup u32assert u32lte.MAX_LEAF_SIZE assert.err="invalid leaf: larger than maximum size of 8192"

            # => [leaf_size, NV, V, K, R]
            exec.set_multi_leaf
        end
    end
end

# GET MULTI-LEAF HELPER
# =================================================================================================

#! Gets a value at the given key.
#!
#! The leaf we're retrieving from is guaranteed to hold more than one key-value
#! pair (provided on the advice stack).
#!
#! Inputs:
#!   Operand stack: [leaf_size, NV, K, R]
#!   Advice stack:  [V1, K2, V2, K2, ...]
#!
#! Outputs:
#!   Operand stack: [V, R]
#!
#! Cycles:
#!  Non-empty: 125 + 3 * pair_count
#!  Empty: 122 + 3 * pair_count
@locals(8192)
proc get_multi_leaf_value
    # First, we'll pipe all the pairs in the leaf from the advice stack.
    # We'll need a pointer, the count of words to copy, and a "commitment" that it should hash to.
    # The node value (its hash) is our commitment, and we can just divide `leaf_size` to get the
    # word count.

    # => [leaf_size, COM=NV, K, R]

    # (2 cycles).
    div.4
    # => [num_words, COM, K, R]

    # We can use our local memory for this. A leaf can have a maximum of 1024 entries, each being
    # a pair of words, for a total max leaf size of 8192.
    # (3 cycles)
    locaddr.0 swap
    # => [num_words, ptr, COM, K, R]

    # Cycles: 56 + 3 * num_words / 2
    exec.mem::pipe_double_words_preimage_to_memory
    # => [ptr_end, K, R]

    # (4 cycles)
    movdn.4 locaddr.0 movdn.4
    # => [K, start_ptr, end_ptr, R]

    # (56 cycles)
    exec.sorted_array::find_key_value
    # => [is_key_found, key_ptr, start_ptr, end_ptr, R]

    if.true

        # If the key was found then key_ptr+4 points to the value we need to load from memory.
        # We can reuse the [start_ptr, end_ptr] part of the stack when loading.
        # => [key_ptr, x, x, R]

        # (2 cycles)
        add.4
        # => [val_ptr, x, x, R]

        # (2 cycles)
        push.0.0
        # => [x, x, key_ptr, x, x, R]

        # (1 cycle)
        movup.2
        # => [val_ptr, x, x, x, x, R]

        # (1 cycle)
        mem_loadw_be
        # => [V, R]
    else
        # If the key wasn't found, then the key's value is an empty word.
        # => [x, x, x, R]

        # (7 cycles)
        drop drop drop padw
        # => [ZERO, R]
    end
end

# SET SINGLE-LEAF HELPERS
# =================================================================================================

#! Inserts or removes a value associated with the given key. The leaf to which we're inserting is
#! guaranteed to be empty.
#!
#! Inputs:
#!   Operand stack: [V, K, R, ...]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
#!
#! Cycles
#!   Insert empty value: X cycles
#!   Insert non-empty value: X cycles
proc set_empty_leaf
    # Check if we're inserting the empty value (X cycles)
    padw eqw
    #=> [V == ZERO, ZERO, V, K, R]

    if.true
        # Inserting an empty value; this is a no-op (4 cycles)
        dropw
        #=> [V (=ZERO), K, R, ...]

        # Prepare stack: verify that the leaf is actually empty
        # (X cycles)
        movupw.2 swapw dup.8 movdn.4 push.LEAF_DEPTH movdn.4
        #=> [V (=ZERO), depth, K[3], R, K, ...]

        # (1 cycle)
        mtree_verify
        #=> [V (=ZERO), depth, K[3], R, K, ...]

        # Prepare stack for return (X cycles)
        movup.4 drop movup.4 drop movupw.2 dropw
        #=> [V (=ZERO), R, ...]
    else
        # Inserting a non-empty value (4 cycles)
        dropw
        #=> [V, K, R, ...]

        # Update advice map
        adv.insert_hdword
        #=> [V, K, R, ...]

        # Compute hash([K, V]); the new node value (NV)
        # (21 cycles)
        dupw.1 swapw hmerge
        # => [NV, K, R]

        # Prepare stack for `mtree_set` (5 cycles)
        movupw.2 dup.8 push.LEAF_DEPTH
        #=> [depth, K[3], R, NV, K]

        # Insert node in Merkle store (29 cycles)
        mtree_set
        #=> [V_in_leaf, R_new, K]

        # Check that V_in_leaf is indeed empty (15 cycles)
        padw assert_eqw
        #=> [R_new, K]

        # Prepare stack for return (9 cycles)
        swapw dropw padw
        #=> [ZERO, R_new]
    end
end

#! Inserts or removes a value associated with the given key. The leaf to which we're inserting is
#! guaranteed to hold a single key-value pair (provided on the advice stack).
#!
#! Inputs:
#!   Operand stack: [V, K, R, ...]
#!   Advice stack:  [K_in_leaf, V_in_leaf]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
#! Cycles:
#!   Remove: X cycles
#!   Insert; leaf single after insertion: X cycles
#!   Insert; leaf multiple after insertion: X cycles
proc set_single_leaf
    # Check if we're inserting or removing a value
    # (X cycles)
    padw eqw
    # => [V==ZERO, ZERO, V, K, R, ...]
    if.true
        # we're removing the value associated with K (if any)

        # (4 cycles)
        dropw
        # => [V, K, R, ...]

        # (X cycles)
        exec.remove_single_leaf
        # => [V_old, R_new]
    else
        # we're inserting the key/value pair

        # (4 cycles)
        dropw
        # => [V, K, R, ...]

        # (X cycles)
        exec.insert_single_leaf
        # => [V_old, R_new]
    end
end

#! Inserts a value at the given key. The leaf to which we're inserting is
#! guaranteed to hold a single key-value pair (provided on the advice stack).
#!
#! Inputs:
#!   Operand stack: [V, K, R, ...]
#!   Advice stack:  [K_in_leaf, V_in_leaf]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
#!
#! Cycles:
#!   Leaf single after insertion: X cycles
#!   Leaf multiple after insertion: X cycles
proc insert_single_leaf
    # Push the leaf pre-image on stack
    # (X cycles)
    adv_push.8
    # => [V_in_leaf, K_in_leaf, V, K, R]

    # Check if the key stored in the leaf is the same as K
    # (X cycles)
    movupw.3 movupw.2 eqw
    # => [K_in_leaf==K, K_in_leaf, K, V_in_leaf, V, R]

    if.true
        # Leaf stays a "single" variant

        # (4 cycles)
        dropw
        # => [K, V_in_leaf, V, R]

        # Update advice map (3 cycles)
        movupw.2 adv.insert_hdword
        # => [V, K, V_in_leaf, R]

        # Compute hash([K, V]); the new node value (NV)
        # (X cycles)
        dupw.1 swapw hmerge
        # => [NV, K, V_in_leaf, R]

        # Prepare stack to update Merkle store
        # (X cycles)
        movupw.3 dup.8 push.LEAF_DEPTH
        # => [depth, K[3], R, NV, K, V_in_leaf]

        # Update Merkle store (29 cycles)
        mtree_set
        # => [NV_old, R_new, K, V_in_leaf]

        # Confirm that claimed `V_in_leaf` from advice provider is correct by checking if
        # `[K, V_in_leaf]` hashes to `NV_old`
        # (33 cycles)
        movupw.2 dupw.3 hmerge assert_eqw
        # => [R_new, V_in_leaf]

        # Clean up stack for return
        # (1 cycle)
        swapw
        # => [V_in_leaf, R_new]
    else
        # Leaf becomes a Multiple kv-pair case

        exec.insert_single_to_multi_leaf
        # => [V_in_leaf, R_new]
    end
end

#! Inserts a key-value pair into a leaf currently containing a single, non-empty pair,
#! converting the leaf to a multi-leaf.
#!
#! Inputs: [K_l, K, V_l, V, R]
#! Outputs: [V_l, R_new]
#!
#! where:
#! - `K_l` is the original key stored in the single-leaf.
#! - `V_l` is the original value stored in the single-leaf.
#! - `K` is the new key to insert.
#! - `V` is the new value to insert.
#! - `R` is the root of the original SMT.
#! - `R_new` is the root of the SMT after the insertion.
@locals(16)
proc insert_single_to_multi_leaf

    # Pairs in leaves are sorted by key, so we need to compare the new key against the existing
    # key.

    dupw dupw.2
    # => [K, K_l, K_l, K, V_l, V, R]

    exec.word::lt
    # => [K_l < K, K_l, K, V_l, V, R]

    # We need a contiguous region of memory containing the sorted pairs. Converting a single-leaf
    # To a multi-leaf will always involve 2 pairs (8 words), so we can use local memory for this.

    if.true
        # => [K_l, K, V_l, V, R]

        # Place our locals as follows:
        #   0..4: K_in_leaf
        #   4..8: V_in_leaf
        #  8..12: K
        # 12..16: V

        loc_storew_be.0 dropw
        # => [K, V_l, V, R]

        # Save K[3], as that is our index `i`.
        dup movdn.12
        # => [K, V_l, V, leaf_index, R]

        loc_storew_be.8 dropw
        # => [V_l, V, leaf_index, R]

        loc_storew_be.4 dropw
        # => [V, leaf_index, R]

        loc_storew_be.12 dropw
        # => [leaf_index, R]
    else
        # => [K_l, K, V_l, V, R]

        # Place our locals as follows:
        #   0..4: K
        #   4..8: V
        #  8..12: K_in_leaf
        # 12..16: V_in_leaf

        loc_storew_be.8 dropw
        # => [K, V_l, V, R]

        # Save K[3], as that is our index `i`.
        dup movdn.12
        # => [K, V_l, V, leaf_index, R]

        loc_storew_be.0 dropw
        # => [V_l, V, leaf_index, R]

        loc_storew_be.12 dropw
        # => [V, leaf_index, R]

        loc_storew_be.4 dropw
        # => [leaf_index, R]
    end

    # => [leaf_index, R]

    # Prepare for hash_memory_words,
    locaddr.12 add.4
    locaddr.0
    # => [start_addr, end_addr, leaf_index, R]

    exec.hash_and_insert_mem
    # => [NV_old, R_new]

    # By nature, if an update transforms a single-leaf to a multi-leaf then
    # we are inserting a new key at this leaf_index. The old value never existed,
    # so it must be an empty word.

    padw swapw dropw
    # => [ZERO, R_new]
end

#! Removes the provided key/value pair from the leaf. The leaf to which we're inserting is
#! guaranteed to hold a single key-value pair (provided on the advice stack). Hence, after the
#! operation, the leaf will be empty.
#!
#! Inputs:
#!   Operand stack: [V (=ZERO), K, R, ...]
#!   Advice stack:  [K_in_leaf, V_in_leaf]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new, ...]
#!
#! Cycles: X
proc remove_single_leaf
    # Push the leaf pre-image on stack
    # (0 cycles)
    adv_push.8
    # => [V_in_leaf, K_in_leaf, V, K, R]

    # Check if the key stored in the leaf is the same as K
    # (X cycles)
    movupw.3 movupw.2 eqw
    # => [K_in_leaf==K, K_in_leaf, K, V_in_leaf, V, R]

    if.true
        # Keys match; we're removing the value associated with K

        # (4 cycles)
        dropw
        # => [K, V_in_leaf, V, R]

        # Update advice map (3 cycles)
        movupw.2 adv.insert_hdword
        # => [V, K, V_in_leaf, R]

        # Prepare the stack for `mtree_set`
        # Note that the new node value will be the empty word, so we can use `V`
        # as the node value (since we confirmed that it's `ZERO`)
        # (7 cycles)
        movupw.3 dup.8 push.LEAF_DEPTH
        # => [depth, K[3], R, V, K, V_in_leaf]

        # (29 cycles)
        mtree_set
        # => [NV_old, R_new, K, V_in_leaf, ...]

        # Confirm that hmerge([K, V_in_leaf]) = NV_old
        # (33 cycles)
        movupw.2 dupw.3 hmerge assert_eqw
        # => [R_new, V_in_leaf, ...]

        # Cleanup stack for return (1 cycle)
        swapw
        # => [V_in_leaf, R_new, ...]
    else
        # Keys don't match; this is a no-op
        # We need to ensure that hash([K_in_leaf, V_in_leaf]) = NV;
        # that is, we need to verify the advice provider's claims.
        # If all checks pass, we're done.

        # => [K_in_leaf, K, V_in_leaf, V, R]

        # We no longer need V, since we're not removing anything
        movupw.3 dropw
        # => [K_in_leaf, K, V_in_leaf, R]

        # Prepare stack for mtree_get
        movupw.3 dup.8 push.LEAF_DEPTH
        # => [depth, K[3], R, K_in_leaf, K, V_in_leaf]

        # Retrieve node value (NV) from merkle tree
        mtree_get
        # => [NV, R, K_in_leaf, K, V_in_leaf]

        # Cleanup stack (we no longer need K)
        movupw.3 dropw
        # => [NV, R, K_in_leaf, V_in_leaf]

        # Ensure that hash([K_in_leaf, V_in_leaf]) == NV
        movupw.2 movupw.3 hmerge assert_eqw
        # => [R]

        # Prepare stack for return
        padw
        # => [ZERO, R]
    end
end

# SET MULTI-LEAF HELPERS
# =================================================================================================

#! Sets a key-value pair in a multi-leaf.
#!
#! Checks if the key is already present in the multi-leaf. If so, it will call either
#! `remove_in_multi_leaf` or `replace_in_multi_leaf` depending on whether the value is being
#! replaced or removed. If the key is not present, it will call `insert_into_leaf`.
#!
#! Inputs:
#!   Operand stack: [leaf_size, NV, V, K, R]
#!
#! Outputs:
#!   Operand stack: [V_old, R_new]
@locals(8192)
proc set_multi_leaf
    # We'll have to pipe all the pairs from the advice stack. Let's get the
    # stack ready for pipe_double_words_preimage_to_memory.

    movdn.12
    # => [NV, V, K, leaf_size, R]

    movupw.2 swapw
    # => [NV, K, V, leaf_size, R]

    dup.12 div.4
    # => [num_words, NV, K, V, leaf_size, R]

    movdn.4
    # => [NV, num_words, K, V, leaf_size, R]

    # COM = NV
    dupw movup.8
    # => [num_words, COM, NV, K, V, leaf_size, R]

    locaddr.0 swap
    # => [num_words, ptr, COM; NV, K, V, leaf_size, R]

    exec.mem::pipe_double_words_preimage_to_memory
    # => [end_ptr; NV, K, V, leaf_size, R]

    movdn.12
    # => [NV, K, V, end_ptr, leaf_size, R]
    swapw.2
    # => [V, K, NV, end_ptr, leaf_size, R]
    locaddr.0 movdn.12
    # => [V, K, NV, start_ptr, end_ptr, leaf_size, R]

    # Prepare for sorted_array::find_key_value

    swapw
    # => [K, V, NV, start_ptr, end_ptr, leaf_size, R]
    movupw.2 dropw
    # => [K, V, start_ptr, end_ptr, leaf_size, R]

    movup.10 drop
    # => [K, V, start_ptr, end_ptr, R]

    swapw dupw.1
    # => [K, V, K, start_ptr, end_ptr, R]

    movup.12 movdn.4
    # => [K, start_ptr, V, K, end_ptr, R]

    movup.13 movdn.5
    # => [K, start_ptr, end_ptr; V, K, R]

    exec.sorted_array::find_key_value
    # => [is_key_found, key_ptr, start_ptr, end_ptr; V, K, R]
    if.true
        # => [key_ptr, start_ptr, end_ptr, V, K, R]

        # We're replacing or removing an existing value.
        # To check which, we'll word-align the stack for a moment.
        push.0
        # => [X, V, K, R]
        swapw padw
        # => [ZERO, V, X, K, R]

        eqw movdn.8
        # => [ZERO, V, V==EMPTY, 0, key_ptr, start_ptr, end_ptr, K, R]

        dropw
        # => [V, V==EMPTY, 0, key_ptr, start_ptr, end_ptr, K, R]

        # Drop 0 to word-align the stack.
        movup.5 drop
        # => [V, V==EMPTY, key_ptr, start_ptr, end_ptr, V, K, R]

        swapw
        # => [V==EMPTY, key_ptr, start_ptr, end_ptr, V, K, R]

        if.true
            exec.remove_in_multi_leaf
        else
            exec.replace_in_multi_leaf
        end
    else
        # => [key_ptr, start_ptr, end_ptr, V, K, R]

        # We still need to check if V is empty, which would make this a no-op.
        push.0
        # => [X, V, K, R]
        swapw padw
        # => [ZERO, V, X, K, R]
        eqw
        if.true
            # No-op case. Clean up the stack.

            # => [ZERO, V, X, K, R]
            dropw swapw dropw
            # => [V, K, R]
            swapw dropw
            # => [V, R]
        else
            # We're inserting a new value in the sorted array.

            # => [ZERO, V, X, K, R]
            dropw
            swapw drop
            # => [key_ptr, start_ptr, end_ptr, V, K, R]

            exec.insert_into_leaf
        end
    end
end

#! Inserts a new key-value pair into a multi-leaf.
#!
#! LOCALS: MAX_LEAF_SIZE of key-value pairs + 4 pointers:
#! - pairs_array_start: pointer to the start of the original leaf data
#! - pairs_array_end: pointer to the end of the original leaf data
#! - cur_read: pointer to the current read position in the original leaf data
#! - cur_write: pointer to the current write position
@locals(8196)
proc insert_into_leaf
    # => [key_ptr, start_ptr, end_ptr, V, K, R]

    # Ensure we have space to insert without exceeding the maximum size of 1024 k-v pairs.
    # We already validated all pointers are u32 and end_ptr >= start_ptr.
    dup.2 dup.2 sub add.8 u32lte.MAX_LEAF_SIZE assert.err="invalid insert: already at maximum size of 8192"

    # => [key_ptr, start_ptr, end_ptr, V, K, R]

    # LOCALS:
    # 0: pairs_array_start
    # 1: pairs_array_end
    # 2: cur_read
    # 3: cur_write

    movdn.2
    # => [start_ptr, end_ptr, key_ptr, V, K, R]

    loc_store.0 # start_ptr
    loc_store.1 # end_ptr
    # => [key_ptr, V, K, R]

    # Save K[3], which is the leaf index `i`.
    dup.5 movdn.9
    # => [key_ptr, V, K, leaf_index, R]

    #
    # STEP 1: Copy from pairs_array_start..key_ptr.
    #

    # cur_read = pairs_array_start
    loc_load.0 loc_store.2

    # cur_write = &LOCALS[4]
    locaddr.4 loc_store.3

    loc_load.2 # cur_read
    # => [cur_read, key_ptr, V, K, leaf_index, R]

    loc_load.3 # cur_write
    # => [cur_write, cur_read, key_ptr, V, K, leaf_index, R]

    movdn.2
    # => [cur_read, read_end=key_ptr, cur_write; V, K, leaf_index, R]

    exec.memcopy_word_range_and_advance_ptrs
    # => [cur_read', cur_write', V, K, leaf_index, R]
    loc_store.2 loc_store.3

    # => [V, K, leaf_index, R]

    #
    # STEP 2: write (K, V) there.
    #

    swapw
    # => [K, V, leaf_index, R]

    loc_load.3 movdn.4 dup.4
    # => [cur_write, K, cur_write, V, leaf_index, R]

    # *cur_write = K
    mem_storew_be dropw
    # => [cur_write, V, leaf_index, R]

    add.4 movdn.4 dup.4
    # => [cur_write, V, cur_write, leaf_index, R]

    # *cur_write = V
    mem_storew_be dropw
    # => [cur_write, leaf_index, R, ]

    # cur_write = &new_pairs[2]
    add.4 loc_store.3
    # => [leaf_index, R]

    #
    # STEP 3: copy from cur_read..pairs_array_end
    #

    loc_load.3 # cur_write
    loc_load.1 # read_end = pairs_array_end
    loc_load.2 # cur_read
    # => [cur_read, read_end, cur_write, leaf_index, R]

    exec.memcopy_word_range_and_advance_ptrs
    # => [cur_read', cur_write', leaf_index, R]

    # Prepare for hash_memory_words and mtree_set.

    drop
    # => [cur_write, leaf_index, R]

    # end_addr = cur_write
    # => [end_addr, leaf_index, R]

    # start_addr = &LOCALS[4]
    locaddr.4
    # => [start_addr, end_addr, leaf_index, R]

    exec.hash_and_insert_mem
    # => [NV_old, R_new]

    # By nature, if this insertion put a value where there wasn't one, then the
    # old value at this key is an empty word.
    padw swapw dropw
    # => [ZERO, R_new]
end

#! Updates the value associated with the given key in a multi-leaf.
proc replace_in_multi_leaf
    # => [key_ptr, start_ptr, end_ptr, V, K, R]

    add.4
    # => [val_ptr, start_ptr, end_ptr, V, K, R]

    padw dup.4
    # => [val_ptr, ZERO, val_ptr, start_ptr, end_ptr, V, K, R]
    mem_loadw_be
    # => [V_old, val_ptr, start_ptr, end_ptr, V, K, R]

    # Word-align the stack for a moment.
    push.0 movdn.4
    # => [V_old, X, V, K, R]

    swapw.2
    # => [V, z, val_ptr, start_ptr, end_ptr, V_old, K, R]
    dup.5
    # => [val_ptr, V, z, val_ptr, start_ptr, end_ptr, V_old, K, R]
    mem_storew_be
    # => [V, z, val_ptr, start_ptr, end_ptr, V_old, K, R]

    # Prepare for hash_memory_words

    dropw
    # => [z, val_ptr, start_ptr, end_ptr, V_old, K, R]
    # => [X, V_old, K, R]

    movupw.2
    # => [K, X, V_old, R]

    movupw.3
    # => [R, K, X, V_old]

    movupw.2
    # => [X, R, K, V_old]
    # => [z, val_ptr, start_ptr, end_ptr, R, K, V_old]

    drop drop
    # => [start_ptr, end_ptr, R, K, V_old]

    dup.6 # K[3]
    # => [leaf_index, start_ptr, end_ptr, R, K, V_old]

    movdn.2
    # => [start_ptr, end_ptr, leaf_index, R; K, V_old]

    exec.hash_and_insert_mem
    # => [NV_old, R_new; K, V_old]

    dropw
    # => [R_new, K, V_old]
    swapw dropw
    # => [R_new, V_old]
    swapw
    # => [V_old, R_new]
end

#! Removes a key-value pair from a multi-leaf.
#!
#! LOCALS: MAX_LEAF_SIZE of key-value pairs + 4 pointers:
#! - pairs_array_start: pointer to the start of the original leaf data
#! - pairs_array_end: pointer to the end of the original leaf data
#! - cur_read: pointer to the current read position in the original leaf data
#! - cur_write: pointer to the current write position
@locals(8196)
proc remove_in_multi_leaf
    # => [key_ptr, start_ptr, end_ptr, V=EMPTY, K, R]

    # LOCALS:
    # 0: pairs_array_start
    # 1: pairs_array_end
    # 2: cur_read
    # 3: cur_write
    # 8..8196: leaf memory space

    movdn.6
    # => [start_ptr, end_ptr, V=EMPTY, key_ptr, K, R]
    dup loc_store.0 # start_ptr
    loc_store.2 # cur_read = start_ptr
    loc_store.1 # end_ptr
    # => [V, key_ptr, K, R]

    # cur_write = &LOCALS[4]
    locaddr.4 loc_store.3
    # => [V=EMPTY, key_ptr, K, R]

    # Get V_in_leaf from key_ptr+4. We'll need it later. Since we know V is an
    # empty word, we can reuse that stack space for mem_loadw_be.

    dup.4 add.4
    # => [val_ptr, V=EMPTY, key_ptr, K, R]
    mem_loadw_be
    # => [V_old, key_ptr, K, R]

    # Shift memory from key_ptr+8..end_ptr to key_ptr, removing the (K, V_old) pair in the process.
    movup.4
    # => [write_ptr=key_ptr, V_old, K, R]

    loc_load.1
    # => [end_ptr=pairs_array_end, write_ptr=key_ptr, V_old, K, R]

    dup.1 add.8
    # => [start_ptr=key_ptr+8, end_ptr=pairs_array_end, write_ptr=key_ptr, V_old, K, R]

    exec.memcopy_word_range_and_advance_ptrs
    # => [cur_read', cur_write'; V_old, K, R]

    drop loc_store.3
    # => [V_old, K, R]

    movupw.2
    # => [R, V_old, K]

    # K[3] is the leaf index.
    dup.8
    # => [leaf_index, R, V_old, K]

    loc_load.3 loc_load.0
    # => [start_addr, end_addr, leaf_index, R; V_old, K]

    exec.hash_and_insert_mem
    # => [NV_old, R_new, V_old, K]

    dropw movupw.2 dropw swapw
    # => [V_old, R_new]
end

# MEMORY HELPERS
# =================================================================================================

#! Copies from the memory range starting at `read_start_ptr` and ending at `read_end_ptr`, to
#! memory starting at `write_ptr`, and returns updated pointers, advanced by how much data was
#! copied.
#!
#! Unlike mem::memcopy_words, this procedure takes a start and end pointer, and does not copy
#! anything if `end - start < 1`.
#!
#! Inputs: [read_start_ptr, read_end_ptr, write_ptr]
#! Outputs: [read_ptr', write_ptr']
#!
#! Where:
#! - `read_ptr'` is `read_start_ptr` plus the count of elements that were copied.
#! - `write_ptr'` is `write_ptr` plus the count of elements that were copied.
proc memcopy_word_range_and_advance_ptrs
    # => [read_start_ptr, read_end_ptr, write_ptr]

    # => [cur_read=read_start_ptr, read_end, cur_write=write_ptr]

    dup movdn.2
    # => [cur_read, read_end, cur_read, cur_write]

    # Our pointers are originally from local memory, whose address range fits in a u32:
    # https://0xmiden.github.io/miden-vm/user_docs/assembly/execution_contexts.html#memory-layout.
    u32overflowing_sub
    # => [ovf, read_end - cur_read, cur_read, cur_write]

    dup.1 neq.0
    # => [nonzero, ovf, read_end - cur_read, cur_read, cur_write]

    # Fewer cycles than xor.
    u32xor
    # => [anything_to_read, read_end - cur_read, cur_read, cur_write]

    if.true
        div.4
        # => [num_words, cur_read, cur_write]

        dup.2 dup.2 dup.2
        # => [num_words, cur_read, cur_write, num_words, cur_read, cur_write]

        exec.mem::memcopy_words
        # => [num_words, cur_read, cur_write]

        mul.4 dup
        # => [num_elems, num_elems, cur_read, cur_write]

        # cur_write += num_elems
        movup.3 add
        # => [cur_write', num_elems, cur_read]

        # cur_read += num_elems
        swap.2 add
        # => [cur_read', cur_write']
    else
        drop
    end
end

#! Hashes an array of SMT leaves, then updates both the advice map and Merkle store.
#!
#! Returns the node value (hash) of the previous leaf at the given index, as well as
#! the root for the new SMT.
#!
#! Inputs: [start_addr, end_addr, leaf_index, R]
#! Outputs: [NV_old, R_new]
proc hash_and_insert_mem
    # => [start_addr, end_addr, leaf_index, R, ...]

    dup.1 dup.1
    # => [start_addr, end_addr, start_addr, end_addr, leaf_index, R, ...]

    exec.rpo::hash_memory_words
    # => [NV, start_addr, end_addr, leaf_index, R, ...]

    adv.insert_mem
    # => [NV, start_addr, end_addr, leaf_index, R, ...]

    # Prepare for mtree_set
    movup.4 drop movup.4 drop
    # => [NV, leaf_index, R, ...]

    movup.4 movdn.8
    # => [NV, R, leaf_index]

    swapw movup.8
    # => [leaf_index, R, NV]

    push.LEAF_DEPTH
    # => [d, leaf_index, R, NV]

    mtree_set
    # => [NV_old, R_new, ...]
end
