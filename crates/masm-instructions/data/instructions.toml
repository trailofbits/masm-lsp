# Miden VM Instruction Reference Data
# This file is parsed at compile time to generate a static instruction lookup table.
# Each instruction has: description, stack_input, stack_output, cycles

# =============================================================================
# FIELD OPERATIONS - Comparison
# =============================================================================

[lte]
description = "Returns 1 if $a \\le b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "15"

["lte.b"]
description = "Returns 1 if $a \\le b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "16"

[lt]
description = "Returns 1 if $a < b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "14"

["lt.b"]
description = "Returns 1 if $a < b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "15"

[gte]
description = "Returns 1 if $a \\ge b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "16"

["gte.b"]
description = "Returns 1 if $a \\ge b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "17"

[gt]
description = "Returns 1 if $a > b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "15"

["gt.b"]
description = "Returns 1 if $a > b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "16"

[eq]
description = "Returns 1 if $a = b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

["eq.b"]
description = "Returns 1 if $a = b$, 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "1-2"

[neq]
description = "Returns 1 if $a \\neq b$, 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["neq.b"]
description = "Returns 1 if $a \\neq b$, 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "2-3"

[eqw]
description = "Returns 1 if $A = B$ element-wise, 0 otherwise."
stack_input = "[A, B, ...]"
stack_output = "[c, A, B, ...]"
cycles = "15"

[is_odd]
description = "Returns 1 if $a$ is odd, 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "5"

# =============================================================================
# FIELD OPERATIONS - Assertions
# =============================================================================

[assert]
description = "Removes $a$ if $a = 1$. Fails if $a \\neq 1$."
stack_input = "[a, ...]"
stack_output = "[...]"
cycles = "1"

[assertz]
description = "Removes $a$ if $a = 0$. Fails if $a \\neq 0$."
stack_input = "[a, ...]"
stack_output = "[...]"
cycles = "2"

[assert_eq]
description = "Removes $a$ and $b$ if $a = b$. Fails if $a \\neq b$."
stack_input = "[b, a, ...]"
stack_output = "[...]"
cycles = "2"

[assert_eqw]
description = "Removes $A$ and $B$ if $A = B$ element-wise. Fails otherwise."
stack_input = "[B, A, ...]"
stack_output = "[...]"
cycles = "11"

# =============================================================================
# FIELD OPERATIONS - Arithmetic
# =============================================================================

[add]
description = "$c = (a + b) \\mod p$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

["add.b"]
description = "$c = (a + b) \\mod p$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "1-2"

[sub]
description = "$c = (a - b) \\mod p$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["sub.b"]
description = "$c = (a - b) \\mod p$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "2"

[mul]
description = "$c = (a \\cdot b) \\mod p$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

["mul.b"]
description = "$c = (a \\cdot b) \\mod p$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "2"

[div]
description = "$c = (a \\cdot b^{-1}) \\mod p$. Fails if $b = 0$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["div.b"]
description = "$c = (a \\cdot b^{-1}) \\mod p$. Fails if $b = 0$."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "2"

[neg]
description = "$b = -a \\mod p$"
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "1"

[inv]
description = "$b = a^{-1} \\mod p$. Fails if $a = 0$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "1"

[incr]
description = "$b = a + 1$"
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "1"

[pow2]
description = "$b = 2^a$. Fails if $a > 63$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "16"

[exp]
description = "$c = a^b$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "9 + log2(b)"

["exp.uxx"]
description = "$c = a^b$ where $b$ is at most $xx$ bits."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "9 + xx"

["exp.b"]
description = "$c = a^b$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "9 + log2(b)"

[ilog2]
description = "$b = \\lfloor \\log_2(a) \\rfloor$. Fails if $a = 0$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "44"

# =============================================================================
# FIELD OPERATIONS - Boolean
# =============================================================================

[not]
description = "$b = 1 - a$. Fails if $a > 1$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "1"

[and]
description = "$c = a \\cdot b$. Fails if $\\max(a, b) > 1$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

[or]
description = "$c = a + b - a \\cdot b$. Fails if $\\max(a, b) > 1$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

[xor]
description = "$c = a + b - 2 \\cdot a \\cdot b$. Fails if $\\max(a, b) > 1$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "7"

# =============================================================================
# FIELD OPERATIONS - Extension Field
# =============================================================================

[ext2add]
description = "Addition in the quadratic extension field."
stack_input = "[b1, b0, a1, a0, ...]"
stack_output = "[c1, c0, ...]"
cycles = "5"

[ext2sub]
description = "Subtraction in the quadratic extension field."
stack_input = "[b1, b0, a1, a0, ...]"
stack_output = "[c1, c0, ...]"
cycles = "7"

[ext2mul]
description = "Multiplication in the quadratic extension field."
stack_input = "[b1, b0, a1, a0, ...]"
stack_output = "[c1, c0, ...]"
cycles = "3"

[ext2neg]
description = "Negation in the quadratic extension field."
stack_input = "[a1, a0, ...]"
stack_output = "[b1, b0, ...]"
cycles = "4"

[ext2inv]
description = "Inverse in the quadratic extension field. Fails if $a = 0$."
stack_input = "[a1, a0, ...]"
stack_output = "[b1, b0, ...]"
cycles = "8"

[ext2div]
description = "Division in the quadratic extension field. Fails if $b = 0$."
stack_input = "[b1, b0, a1, a0, ...]"
stack_output = "[c1, c0, ...]"
cycles = "11"

# =============================================================================
# U32 OPERATIONS - Conversions and Tests
# =============================================================================

[u32test]
description = "$b = 1$ if $a < 2^{32}$, $0$ otherwise."
stack_input = "[a, ...]"
stack_output = "[b, a, ...]"
cycles = "5"

[u32testw]
description = "$b = 1$ if all elements of $A < 2^{32}$, $0$ otherwise."
stack_input = "[A, ...]"
stack_output = "[b, A, ...]"
cycles = "23"

[u32assert]
description = "Fails if $a \\ge 2^{32}$."
stack_input = "[a, ...]"
stack_output = "[a, ...]"
cycles = "3"

[u32assert2]
description = "Fails if $a \\ge 2^{32}$ or $b \\ge 2^{32}$."
stack_input = "[b, a, ...]"
stack_output = "[b, a, ...]"
cycles = "1"

[u32assertw]
description = "Fails if any element of $A \\ge 2^{32}$."
stack_input = "[A, ...]"
stack_output = "[A, ...]"
cycles = "6"

[u32cast]
description = "$b = a \\mod 2^{32}$"
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "2"

[u32split]
description = "$b = a \\mod 2^{32}$, $c = \\lfloor a / 2^{32} \\rfloor$"
stack_input = "[a, ...]"
stack_output = "[c, b, ...]"
cycles = "1"

# =============================================================================
# U32 OPERATIONS - Arithmetic
# =============================================================================

[u32overflowing_add]
description = "$c = (a + b) \\mod 2^{32}$, $d$ is the overflow flag."
stack_input = "[b, a, ...]"
stack_output = "[d, c, ...]"
cycles = "1"

["u32overflowing_add.b"]
description = "$c = (a + b) \\mod 2^{32}$, $d$ is the overflow flag."
stack_input = "[a, ...]"
stack_output = "[d, c, ...]"
cycles = "2-3"

[u32wrapping_add]
description = "$c = (a + b) \\mod 2^{32}$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["u32wrapping_add.b"]
description = "$c = (a + b) \\mod 2^{32}$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3-4"

[u32overflowing_add3]
description = "$d = (a + b + c) \\mod 2^{32}$, $e$ is the overflow."
stack_input = "[c, b, a, ...]"
stack_output = "[e, d, ...]"
cycles = "1"

[u32wrapping_add3]
description = "$d = (a + b + c) \\mod 2^{32}$"
stack_input = "[c, b, a, ...]"
stack_output = "[d, ...]"
cycles = "2"

[u32overflowing_sub]
description = "$c = (a - b) \\mod 2^{32}$, $d$ is the borrow flag."
stack_input = "[b, a, ...]"
stack_output = "[d, c, ...]"
cycles = "1"

["u32overflowing_sub.b"]
description = "$c = (a - b) \\mod 2^{32}$, $d$ is the borrow flag."
stack_input = "[a, ...]"
stack_output = "[d, c, ...]"
cycles = "2-3"

[u32wrapping_sub]
description = "$c = (a - b) \\mod 2^{32}$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["u32wrapping_sub.b"]
description = "$c = (a - b) \\mod 2^{32}$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3-4"

[u32overflowing_mul]
description = "$c = (a \\cdot b) \\mod 2^{32}$, $d$ is the upper 32 bits."
stack_input = "[b, a, ...]"
stack_output = "[d, c, ...]"
cycles = "1"

["u32overflowing_mul.b"]
description = "$c = (a \\cdot b) \\mod 2^{32}$, $d$ is the upper 32 bits."
stack_input = "[a, ...]"
stack_output = "[d, c, ...]"
cycles = "2-3"

[u32wrapping_mul]
description = "$c = (a \\cdot b) \\mod 2^{32}$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["u32wrapping_mul.b"]
description = "$c = (a \\cdot b) \\mod 2^{32}$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3-4"

[u32overflowing_madd]
description = "$d = (a \\cdot b + c) \\mod 2^{32}$, $e$ is the upper 32 bits."
stack_input = "[b, a, c, ...]"
stack_output = "[e, d, ...]"
cycles = "1"

[u32wrapping_madd]
description = "$d = (a \\cdot b + c) \\mod 2^{32}$"
stack_input = "[b, a, c, ...]"
stack_output = "[d, ...]"
cycles = "2"

[u32div]
description = "$c = \\lfloor a / b \\rfloor$. Fails if $b = 0$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "2"

["u32div.b"]
description = "$c = \\lfloor a / b \\rfloor$. Fails if $b = 0$."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3-4"

[u32mod]
description = "$c = a \\mod b$. Fails if $b = 0$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "3"

["u32mod.b"]
description = "$c = a \\mod b$. Fails if $b = 0$."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "4-5"

[u32divmod]
description = "$c = \\lfloor a / b \\rfloor$, $d = a \\mod b$. Fails if $b = 0$."
stack_input = "[b, a, ...]"
stack_output = "[d, c, ...]"
cycles = "1"

["u32divmod.b"]
description = "$c = \\lfloor a / b \\rfloor$, $d = a \\mod b$. Fails if $b = 0$."
stack_input = "[a, ...]"
stack_output = "[d, c, ...]"
cycles = "2-3"

# =============================================================================
# U32 OPERATIONS - Bitwise
# =============================================================================

[u32and]
description = "Bitwise AND of $a$ and $b$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

["u32and.b"]
description = "Bitwise AND of $a$ and $b$."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "2"

[u32or]
description = "Bitwise OR of $a$ and $b$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "6"

["u32or.b"]
description = "Bitwise OR of $a$ and $b$."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "7"

[u32xor]
description = "Bitwise XOR of $a$ and $b$."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "1"

["u32xor.b"]
description = "Bitwise XOR of $a$ and $b$."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "2"

[u32not]
description = "Bitwise NOT of $a$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "5"

["u32not.a"]
description = "Bitwise NOT of immediate $a$."
stack_input = "[...]"
stack_output = "[b, ...]"
cycles = "6"

[u32shl]
description = "$c = (a \\cdot 2^b) \\mod 2^{32}$. Left shift."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "18"

["u32shl.b"]
description = "$c = (a \\cdot 2^b) \\mod 2^{32}$. Left shift by immediate."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3"

[u32shr]
description = "$c = \\lfloor a / 2^b \\rfloor$. Right shift."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "18"

["u32shr.b"]
description = "$c = \\lfloor a / 2^b \\rfloor$. Right shift by immediate."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3"

[u32rotl]
description = "Rotate $a$ left by $b$ bits."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "18"

["u32rotl.b"]
description = "Rotate $a$ left by immediate $b$ bits."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3"

[u32rotr]
description = "Rotate $a$ right by $b$ bits."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "23"

["u32rotr.b"]
description = "Rotate $a$ right by immediate $b$ bits."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "3"

[u32popcnt]
description = "Population count (Hamming weight) of $a$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "33"

[u32clz]
description = "Count leading zeros in $a$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "42"

[u32ctz]
description = "Count trailing zeros in $a$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "34"

[u32clo]
description = "Count leading ones in $a$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "41"

[u32cto]
description = "Count trailing ones in $a$."
stack_input = "[a, ...]"
stack_output = "[b, ...]"
cycles = "33"

# =============================================================================
# U32 OPERATIONS - Comparison
# =============================================================================

[u32lt]
description = "Returns 1 if $a < b$ (unsigned), 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "3"

["u32lt.b"]
description = "Returns 1 if $a < b$ (unsigned), 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "4"

[u32lte]
description = "Returns 1 if $a \\le b$ (unsigned), 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "5"

["u32lte.b"]
description = "Returns 1 if $a \\le b$ (unsigned), 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "6"

[u32gt]
description = "Returns 1 if $a > b$ (unsigned), 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "4"

["u32gt.b"]
description = "Returns 1 if $a > b$ (unsigned), 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "5"

[u32gte]
description = "Returns 1 if $a \\ge b$ (unsigned), 0 otherwise."
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "4"

["u32gte.b"]
description = "Returns 1 if $a \\ge b$ (unsigned), 0 otherwise."
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "5"

[u32min]
description = "$c = \\min(a, b)$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "8"

["u32min.b"]
description = "$c = \\min(a, b)$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "9"

[u32max]
description = "$c = \\max(a, b)$"
stack_input = "[b, a, ...]"
stack_output = "[c, ...]"
cycles = "9"

["u32max.b"]
description = "$c = \\max(a, b)$"
stack_input = "[a, ...]"
stack_output = "[c, ...]"
cycles = "10"

# =============================================================================
# STACK MANIPULATION
# =============================================================================

[drop]
description = "Deletes the top stack item."
stack_input = "[a, ...]"
stack_output = "[...]"
cycles = "1"

[dropw]
description = "Deletes a word (4 elements) from the top of the stack."
stack_input = "[A, ...]"
stack_output = "[...]"
cycles = "4"

[padw]
description = "Pushes four zeros onto the stack."
stack_input = "[...]"
stack_output = "[0, 0, 0, 0, ...]"
cycles = "4"

[dup]
description = "Pushes a copy of the top stack item."
stack_input = "[a, ...]"
stack_output = "[a, a, ...]"
cycles = "1"

[dupw]
description = "Pushes a copy of the top stack word (4 elements)."
stack_input = "[A, ...]"
stack_output = "[A, A, ...]"
cycles = "4"

[swap]
description = "Swaps the top two stack items."
stack_input = "[b, a, ...]"
stack_output = "[a, b, ...]"
cycles = "1"

[swapw]
description = "Swaps the top two stack words."
stack_input = "[B, A, ...]"
stack_output = "[A, B, ...]"
cycles = "1"

[swapdw]
description = "Swaps words 0-1 with words 2-3."
stack_input = "[D, C, B, A, ...]"
stack_output = "[B, A, D, C, ...]"
cycles = "1"

[movup]
description = "Moves the $n$-th stack item to the top."
stack_input = "[..., a, ...]"
stack_output = "[a, ...]"
cycles = "1-4"

[movupw]
description = "Moves the $n$-th stack word to the top."
stack_input = "[..., A, ...]"
stack_output = "[A, ...]"
cycles = "2-3"

[movdn]
description = "Moves the top stack item to the $n$-th position."
stack_input = "[a, ...]"
stack_output = "[..., a, ...]"
cycles = "1-4"

[movdnw]
description = "Moves the top stack word to the $n$-th position."
stack_input = "[A, ...]"
stack_output = "[..., A, ...]"
cycles = "2-3"

[reversew]
description = "Reverses the order of elements in the top word."
stack_input = "[a3, a2, a1, a0, ...]"
stack_output = "[a0, a1, a2, a3, ...]"
cycles = "1"

# =============================================================================
# STACK MANIPULATION - Conditional
# =============================================================================

[cswap]
description = "If $c = 1$: $d = b$, $e = a$. If $c = 0$: $d = a$, $e = b$."
stack_input = "[c, b, a, ...]"
stack_output = "[e, d, ...]"
cycles = "1"

[cswapw]
description = "If $c = 1$: swap words $A$ and $B$. If $c = 0$: no change."
stack_input = "[c, B, A, ...]"
stack_output = "[E, D, ...]"
cycles = "1"

[cdrop]
description = "If $c = 1$: $d = b$. If $c = 0$: $d = a$."
stack_input = "[c, b, a, ...]"
stack_output = "[d, ...]"
cycles = "2"

[cdropw]
description = "If $c = 1$: $D = B$. If $c = 0$: $D = A$."
stack_input = "[c, B, A, ...]"
stack_output = "[D, ...]"
cycles = "5"

# =============================================================================
# INPUT/OUTPUT - Constants
# =============================================================================

[push]
description = "Pushes one or more field elements onto the stack."
stack_input = "[...]"
stack_output = "[a, ...]"
cycles = "1-2"

# =============================================================================
# INPUT/OUTPUT - Environment
# =============================================================================

[clk]
description = "Pushes the current clock cycle onto the stack."
stack_input = "[...]"
stack_output = "[t, ...]"
cycles = "1"

[sdepth]
description = "Pushes the current stack depth onto the stack."
stack_input = "[...]"
stack_output = "[d, ...]"
cycles = "1"

[caller]
description = "Pushes the hash of the caller's function onto the stack."
stack_input = "[A, b, ...]"
stack_output = "[H, b, ...]"
cycles = "1"

[locaddr]
description = "Pushes the absolute memory address of local index $i$."
stack_input = "[...]"
stack_output = "[a, ...]"
cycles = "2"

[procref]
description = "Pushes the MAST root of the referenced procedure."
stack_input = "[...]"
stack_output = "[A, ...]"
cycles = "4"

# =============================================================================
# INPUT/OUTPUT - Advice Provider
# =============================================================================

[adv_push]
description = "Pops $n$ values from the advice stack onto the operand stack."
stack_input = "[...]"
stack_output = "[a, ...]"
cycles = "n"

[adv_loadw]
description = "Pops a word from the advice stack and overwrites the top word."
stack_input = "[0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "1"

[adv_pipe]
description = "Pops two words from advice stack, writes to memory and stack."
stack_input = "[C, B, A, a, ...]"
stack_output = "[E, D, A, a', ...]"
cycles = "1"

["adv.push_mapval"]
description = "Pushes values from advice_map[K] onto the advice stack."
stack_input = "[K, ...]"
stack_output = "[K, ...]"
cycles = "3"

["adv.push_mapvaln"]
description = "Pushes [n, ...values] from advice_map[K] onto the advice stack."
stack_input = "[K, ...]"
stack_output = "[K, ...]"
cycles = "3"

["adv.push_mtnode"]
description = "Pushes a Merkle tree node onto the advice stack."
stack_input = "[d, i, R, ...]"
stack_output = "[d, i, R, ...]"
cycles = "3"

["adv.insert_mem"]
description = "Inserts memory range mem[a..b] into advice_map with key K."
stack_input = "[K, a, b, ...]"
stack_output = "[K, a, b, ...]"
cycles = "3"

["adv.insert_hdword"]
description = "Inserts hash(A||B) into advice_map."
stack_input = "[B, A, ...]"
stack_output = "[B, A, ...]"
cycles = "3"

["adv.insert_hdword_d"]
description = "Inserts hash(A||B, domain=d) into advice_map."
stack_input = "[B, A, d, ...]"
stack_output = "[B, A, d, ...]"
cycles = "3"

["adv.insert_hqword"]
description = "Inserts hash(A||B||C||D) into advice_map."
stack_input = "[D, C, B, A, ...]"
stack_output = "[D, C, B, A, ...]"
cycles = "3"

["adv.insert_hperm"]
description = "Inserts permute(C, A, B).digest into advice_map."
stack_input = "[B, A, C, ...]"
stack_output = "[B, A, C, ...]"
cycles = "3"

# =============================================================================
# INPUT/OUTPUT - Memory
# =============================================================================

[mem_load]
description = "Loads a field element from memory address $a$."
stack_input = "[a, ...]"
stack_output = "[v, ...]"
cycles = "1"

["mem_load.a"]
description = "Loads a field element from immediate memory address."
stack_input = "[...]"
stack_output = "[v, ...]"
cycles = "2"

[mem_loadw_be]
description = "Loads a word from memory (big-endian)."
stack_input = "[a, 0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "1"

["mem_loadw_be.a"]
description = "Loads a word from immediate address (big-endian)."
stack_input = "[0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "2"

[mem_loadw_le]
description = "Loads a word from memory (little-endian)."
stack_input = "[a, 0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "4"

["mem_loadw_le.a"]
description = "Loads a word from immediate address (little-endian)."
stack_input = "[0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "5"

[mem_store]
description = "Stores a field element to memory address $a$."
stack_input = "[a, v, ...]"
stack_output = "[...]"
cycles = "2"

["mem_store.a"]
description = "Stores a field element to immediate memory address."
stack_input = "[v, ...]"
stack_output = "[...]"
cycles = "3-4"

[mem_storew_be]
description = "Stores a word to memory (big-endian)."
stack_input = "[a, A, ...]"
stack_output = "[A, ...]"
cycles = "1"

["mem_storew_be.a"]
description = "Stores a word to immediate address (big-endian)."
stack_input = "[A, ...]"
stack_output = "[A, ...]"
cycles = "2-3"

[mem_storew_le]
description = "Stores a word to memory (little-endian)."
stack_input = "[a, A, ...]"
stack_output = "[A, ...]"
cycles = "9"

["mem_storew_le.a"]
description = "Stores a word to immediate address (little-endian)."
stack_input = "[A, ...]"
stack_output = "[A, ...]"
cycles = "8-9"

[mem_stream]
description = "Streams two sequential words from memory."
stack_input = "[C, B, A, a, ...]"
stack_output = "[E, D, A, a', ...]"
cycles = "1"

# =============================================================================
# INPUT/OUTPUT - Procedure Locals
# =============================================================================

[loc_load]
description = "Loads a field element from local memory at index $i$."
stack_input = "[...]"
stack_output = "[v, ...]"
cycles = "5-6"

[loc_loadw_be]
description = "Loads a word from local memory (big-endian)."
stack_input = "[0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "5-6"

[loc_loadw_le]
description = "Loads a word from local memory (little-endian)."
stack_input = "[0, 0, 0, 0, ...]"
stack_output = "[A, ...]"
cycles = "9-10"

[loc_store]
description = "Stores a field element to local memory at index $i$."
stack_input = "[v, ...]"
stack_output = "[...]"
cycles = "6-7"

[loc_storew_be]
description = "Stores a word to local memory (big-endian)."
stack_input = "[A, ...]"
stack_output = "[A, ...]"
cycles = "5-6"

[loc_storew_le]
description = "Stores a word to local memory (little-endian)."
stack_input = "[A, ...]"
stack_output = "[A, ...]"
cycles = "13-14"

# =============================================================================
# CRYPTOGRAPHIC OPERATIONS
# =============================================================================

[hash]
description = "Computes 1-to-1 Rescue Prime Optimized hash of word $A$."
stack_input = "[A, ...]"
stack_output = "[B, ...]"
cycles = "20"

[hperm]
description = "Applies Rescue Prime Optimized permutation."
stack_input = "[B, A, C, ...]"
stack_output = "[F, E, D, ...]"
cycles = "1"

[hmerge]
description = "Computes 2-to-1 Rescue Prime Optimized hash."
stack_input = "[B, A, ...]"
stack_output = "[C, ...]"
cycles = "16"

[mtree_get]
description = "Verifies Merkle path and returns node value."
stack_input = "[d, i, R, ...]"
stack_output = "[V, R, ...]"
cycles = "9"

[mtree_set]
description = "Updates a node in a Merkle tree, returns old value and new root."
stack_input = "[d, i, R, V', ...]"
stack_output = "[V, R', ...]"
cycles = "29"

[mtree_merge]
description = "Merges two Merkle trees into one."
stack_input = "[R, L, ...]"
stack_output = "[M, ...]"
cycles = "16"

[mtree_verify]
description = "Verifies that node $V$ exists at index $i$ in tree with root $R$."
stack_input = "[V, d, i, R, ...]"
stack_output = "[V, d, i, R, ...]"
cycles = "1"

# =============================================================================
# FLOW CONTROL
# =============================================================================

[nop]
description = "No operation. Advances the cycle counter by 1."
stack_input = "[...]"
stack_output = "[...]"
cycles = "1"

["if.true"]
description = "Executes the first branch if top of stack is 1, else the second."
stack_input = "[c, ...]"
stack_output = "[...]"
cycles = "variable"

["if.false"]
description = "Executes the first branch if top of stack is 0, else the second."
stack_input = "[c, ...]"
stack_output = "[...]"
cycles = "variable"

[repeat]
description = "Executes the body COUNT times (unrolled at compile time)."
stack_input = "[...]"
stack_output = "[...]"
cycles = "variable"

["while.true"]
description = "Executes the body while top of stack is 1."
stack_input = "[c, ...]"
stack_output = "[...]"
cycles = "variable"

# =============================================================================
# EVENTS
# =============================================================================

[emit]
description = "Emits an event with the given ID to the host."
stack_input = "[event_id, ...]"
stack_output = "[event_id, ...]"
cycles = "1"

[trace]
description = "Emits a trace event to the host (debug mode only)."
stack_input = "[...]"
stack_output = "[...]"
cycles = "0"

[log_precompile]
description = "Absorbs a precompile commitment into the transcript."
stack_input = "[COMM, TAG, PAD, ...]"
stack_output = "[R1, R0, CAP_NEXT, ...]"
cycles = "1"

# =============================================================================
# DEBUGGING
# =============================================================================

[debug]
description = "Prints VM state (debug mode only, 0 cycles)."
stack_input = "[...]"
stack_output = "[...]"
cycles = "0"

["debug.stack"]
description = "Prints the entire operand stack."
stack_input = "[...]"
stack_output = "[...]"
cycles = "0"

["debug.mem"]
description = "Prints the entire RAM state."
stack_input = "[...]"
stack_output = "[...]"
cycles = "0"

["debug.local"]
description = "Prints the local memory of the current procedure."
stack_input = "[...]"
stack_output = "[...]"
cycles = "0"

# =============================================================================
# PROCEDURE INVOCATION
# =============================================================================

[exec]
description = "Executes a procedure by inlining its code."
stack_input = "[...]"
stack_output = "[...]"
cycles = "variable"

[call]
description = "Calls a procedure, creating a new execution context."
stack_input = "[...]"
stack_output = "[...]"
cycles = "variable"

[syscall]
description = "Invokes a kernel procedure."
stack_input = "[...]"
stack_output = "[...]"
cycles = "variable"

[dynexec]
description = "Executes a procedure dynamically by MAST root on stack."
stack_input = "[H, ...]"
stack_output = "[...]"
cycles = "variable"

[dyncall]
description = "Calls a procedure dynamically by MAST root on stack."
stack_input = "[H, ...]"
stack_output = "[...]"
cycles = "variable"
